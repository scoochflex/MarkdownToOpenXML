using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;

using System;
using System.Collections.Generic;
using System.Linq;

namespace MarkdownParser
{
  /// <summary>
  /// Description of Parser.
  /// </summary>
    [PegGrammar(Options = EmitDebugSources, document,
    grammar
    {
        any : char = ['\u0000'..'\uFFFF'];
        anyChar : char = !('\n' / '\r') any;
        number = ['0' .. '9'];
        nonvoidnewline = ("\n\r" / "\r\n" / '\r' / 'n');
        content : ContentNode = anyChar;
        newline : void = nonvoidnewline;
        newlines : void = newline+;
        heading : Node = '#'+ (!('#') anyChar)* '#'* newlines?;
        docPiece : Node = heading;
        paragraph: Node = (!docPiece anyChar+ newline?)+;
        linebreak : Node = nonvoidnewline;
        document : List[Node] = (docPiece / paragraph / linebreak)*;
      //Rules
    }
  )]
  public class Parser
  {
      public mutable filename : string;
      content(x : char):ContentNode
      {
          ContentNode(ContentNode.NodeType.Text(),x.ToString());
      }
      heading(_ : NToken, x: List[char], _ : NToken):Node
      {
          def text = string.Join("",x);
          Node(Node.NodeType.Heading(),text);
      }
      linebreak(_ : NToken):Node
      {
          Node(Node.NodeType.LineBreak(),"");
      }
      any(letter: NToken):char
      {
          GetText(letter)[0]
      }
      paragraph( letters : List[List[char]]):Node
      {
          def text = string.Join("",letters.Select((x)=>string.Join("",x)));
          Node(Node.NodeType.Paragraph(),text)
      }
      document (pieces:List[Node]):List[Node]
      {
          pieces
      }
  }
}
